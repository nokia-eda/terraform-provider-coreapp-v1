// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_topo_node

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func TopoNodeDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"hash": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "resource content will be returned as it was at the time of this git hash",
				MarkdownDescription: "resource content will be returned as it was at the time of this git hash",
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"namespace": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "name of the TopoNode",
				MarkdownDescription: "name of the TopoNode",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"component": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"kind": schema.StringAttribute{
									Optional:            true,
									Description:         "The kind of Component, e.g. lineCard.",
									MarkdownDescription: "The kind of Component, e.g. lineCard.",
								},
								"slot": schema.StringAttribute{
									Optional:            true,
									Description:         "The slot this Component resides in, unset for Components that do not have a slot or ID.\ne.g. 1 would denote the linecard slot 1, 1/1 would denote linecard slot 1 mda slot 1.",
									MarkdownDescription: "The slot this Component resides in, unset for Components that do not have a slot or ID.\ne.g. 1 would denote the linecard slot 1, 1/1 would denote linecard slot 1 mda slot 1.",
								},
								"type": schema.StringAttribute{
									Optional:            true,
									Description:         "Denotes the type of hardware being provisioned, e.g. xcm-x20.",
									MarkdownDescription: "Denotes the type of hardware being provisioned, e.g. xcm-x20.",
								},
							},
							CustomType: ComponentType{
								ObjectType: types.ObjectType{
									AttrTypes: ComponentValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "List of components within the TopoNode.\nUsed to define the type and location of linecards, fabrics (SFM), media adapter cards (MDA) and control cards (CPM).",
						MarkdownDescription: "List of components within the TopoNode.\nUsed to define the type and location of linecards, fabrics (SFM), media adapter cards (MDA) and control cards (CPM).",
					},
					"license": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to a ConfigMap containing a license for the TopoNode. Overrides the license set in the referenced NodeProfile, if present.",
						MarkdownDescription: "Reference to a ConfigMap containing a license for the TopoNode. Overrides the license set in the referenced NodeProfile, if present.",
					},
					"mac_address": schema.StringAttribute{
						Optional:            true,
						Description:         "MAC address to associate with this TopoNode.\nTypically the chassis MAC address, optionally sent by a node in DHCP requests.\nNot required when a TopoNode is not being bootstrapped by EDA, or is simulated through CX.",
						MarkdownDescription: "MAC address to associate with this TopoNode.\nTypically the chassis MAC address, optionally sent by a node in DHCP requests.\nNot required when a TopoNode is not being bootstrapped by EDA, or is simulated through CX.",
					},
					"node_profile": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to a NodeProfile to use with this TopoNode.",
						MarkdownDescription: "Reference to a NodeProfile to use with this TopoNode.",
					},
					"npp": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"mode": schema.StringAttribute{
								Optional:            true,
								Description:         "The mode in which this TopoNode is functioning.\n\"normal\" (the default)\n   indicates that NPP is expecting an endpoint to exist, and will accept and confirm changes only if the endpoint\n   accepts them.\n\"maintenance\"\n   indicates that no changes will be accepted for the TopoNode, irrespective if the endpoint is up and reachable.\n   The exception is if an upgrade is occuring, in which case changes will be accepted.\n\"null\"\n\t  indicates that changes will be accepted from CRs and no NPP will be spun up. NPP validation will not occur.\n   This may be useful in playground mode to avoid spinning up of 1000s of NPPs.\n\"emulate\"\n   indicates that changes will be accepted at the NPP level, without pushing them to a endpoint. NPP validation\n   still occurs.  If no IP address is present, we also run in emulate mode.",
								MarkdownDescription: "The mode in which this TopoNode is functioning.\n\"normal\" (the default)\n   indicates that NPP is expecting an endpoint to exist, and will accept and confirm changes only if the endpoint\n   accepts them.\n\"maintenance\"\n   indicates that no changes will be accepted for the TopoNode, irrespective if the endpoint is up and reachable.\n   The exception is if an upgrade is occuring, in which case changes will be accepted.\n\"null\"\n\t  indicates that changes will be accepted from CRs and no NPP will be spun up. NPP validation will not occur.\n   This may be useful in playground mode to avoid spinning up of 1000s of NPPs.\n\"emulate\"\n   indicates that changes will be accepted at the NPP level, without pushing them to a endpoint. NPP validation\n   still occurs.  If no IP address is present, we also run in emulate mode.",
							},
						},
						CustomType: NppType{
							ObjectType: types.ObjectType{
								AttrTypes: NppValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Options relating to NPP interactions with the node.",
						MarkdownDescription: "Options relating to NPP interactions with the node.",
					},
					"on_boarded": schema.BoolAttribute{
						Optional:            true,
						Description:         "Indicates if this TopoNode has been bootstrapped or is reachable via configured credentials. Set by BootstrapServer when it completes onboarding functions for a given TopoNode.\nMost applications ignore TopoNodes that have not been onboarded yet.",
						MarkdownDescription: "Indicates if this TopoNode has been bootstrapped or is reachable via configured credentials. Set by BootstrapServer when it completes onboarding functions for a given TopoNode.\nMost applications ignore TopoNodes that have not been onboarded yet.",
					},
					"operating_system": schema.StringAttribute{
						Optional:            true,
						Description:         "Operating system running on this TopoNode, e.g. srl.",
						MarkdownDescription: "Operating system running on this TopoNode, e.g. srl.",
					},
					"platform": schema.StringAttribute{
						Optional:            true,
						Description:         "Platform type of this TopoNode, e.g. 7220 IXR-D3L.",
						MarkdownDescription: "Platform type of this TopoNode, e.g. 7220 IXR-D3L.",
					},
					"production_address": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"ipv4": schema.StringAttribute{
								Optional:            true,
								Description:         "The IPv4 production address",
								MarkdownDescription: "The IPv4 production address",
							},
							"ipv6": schema.StringAttribute{
								Optional:            true,
								Description:         "The IPv6 production address",
								MarkdownDescription: "The IPv6 production address",
							},
						},
						CustomType: ProductionAddressType{
							ObjectType: types.ObjectType{
								AttrTypes: ProductionAddressValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Production address of this TopoNode - this is the address the real, production instance of this TopoNode uses.\nIf left blank, an address will be allocated from the management IP pool specified in the referenced NodeProfile.\nIf this TopoNode is not bootstrapped by EDA this field must be provided.",
						MarkdownDescription: "Production address of this TopoNode - this is the address the real, production instance of this TopoNode uses.\nIf left blank, an address will be allocated from the management IP pool specified in the referenced NodeProfile.\nIf this TopoNode is not bootstrapped by EDA this field must be provided.",
					},
					"serial_number": schema.StringAttribute{
						Optional:            true,
						Description:         "Serial number of this TopoNode, optionally sent by a node in DHCP requests.\nNot required when a TopoNode is not being bootstrapped by EDA, or is simulated through CX.",
						MarkdownDescription: "Serial number of this TopoNode, optionally sent by a node in DHCP requests.\nNot required when a TopoNode is not being bootstrapped by EDA, or is simulated through CX.",
					},
					"system_interface": schema.StringAttribute{
						Optional:            true,
						Description:         "Deprecated: Name of the Interface resource representing the primary loopback on the TopoNode, this field will be removed in the future version.",
						MarkdownDescription: "Deprecated: Name of the Interface resource representing the primary loopback on the TopoNode, this field will be removed in the future version.",
					},
					"version": schema.StringAttribute{
						Optional:            true,
						Description:         "Sets the software version of this TopoNode, e.g. 24.7.1 (for srl), or 24.7.r1 (for sros).",
						MarkdownDescription: "Sets the software version of this TopoNode, e.g. 24.7.1 (for srl), or 24.7.r1 (for sros).",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "A managed network element is represented via a TopoNode resource, describing characteristics of a specific element in the topology.",
				MarkdownDescription: "A managed network element is represented via a TopoNode resource, describing characteristics of a specific element in the topology.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"node_details": schema.StringAttribute{
						Computed:            true,
						Description:         "Address and port used to connected to the node.",
						MarkdownDescription: "Address and port used to connected to the node.",
					},
					"node_state": schema.StringAttribute{
						Computed:            true,
						Description:         "The current state of the connection between NPP and the node.\n\"TryingToConnect\"\n   NPP is attempting to connect and establish connectivity to the node\n\"WaitingForInitialCfg\"\n   NPP is connected to the node but waiting for intial config to push\n\"Committing\"\n\t  NPP is in progress of commiting\n\"RetryingCommit\"\n   NPP lost sync to node and is re-pushing current config\n\"Synced\"\n   NPP is in fully synced state\n\"Standby\"\n   NPP is running in standby mode. This state is only used on standby clusters with georedundancy.\n\"NoIpAddress\"\n   NPP is running but there is no IP address for node. This only happen in sim setups when\n   CX has not created the simulated node, or the simulated pod failed to launch due to image error.",
						MarkdownDescription: "The current state of the connection between NPP and the node.\n\"TryingToConnect\"\n   NPP is attempting to connect and establish connectivity to the node\n\"WaitingForInitialCfg\"\n   NPP is connected to the node but waiting for intial config to push\n\"Committing\"\n\t  NPP is in progress of commiting\n\"RetryingCommit\"\n   NPP lost sync to node and is re-pushing current config\n\"Synced\"\n   NPP is in fully synced state\n\"Standby\"\n   NPP is running in standby mode. This state is only used on standby clusters with georedundancy.\n\"NoIpAddress\"\n   NPP is running but there is no IP address for node. This only happen in sim setups when\n   CX has not created the simulated node, or the simulated pod failed to launch due to image error.",
					},
					"npp_details": schema.StringAttribute{
						Computed:            true,
						Description:         "NPP address and port for this TopoNode.",
						MarkdownDescription: "NPP address and port for this TopoNode.",
					},
					"npp_pod": schema.StringAttribute{
						Computed:            true,
						Description:         "NPP pod name",
						MarkdownDescription: "NPP pod name",
					},
					"npp_state": schema.StringAttribute{
						Computed:            true,
						Description:         "The current state of the connection between ConfigEngine and NPP.",
						MarkdownDescription: "The current state of the connection between ConfigEngine and NPP.",
					},
					"operating_system": schema.StringAttribute{
						Computed:            true,
						Description:         "Operational operating system running on this TopoNode, e.g. srl, sros.",
						MarkdownDescription: "Operational operating system running on this TopoNode, e.g. srl, sros.",
					},
					"platform": schema.StringAttribute{
						Computed:            true,
						Description:         "Operational platform type of this TopoNode, e.g. 7220 IXR-D3L.",
						MarkdownDescription: "Operational platform type of this TopoNode, e.g. 7220 IXR-D3L.",
					},
					"simulate": schema.BoolAttribute{
						Computed:            true,
						Description:         "Simulate using CX - if true CX is reponsible for generating the TargetNode resource.",
						MarkdownDescription: "Simulate using CX - if true CX is reponsible for generating the TargetNode resource.",
					},
					"version": schema.StringAttribute{
						Computed:            true,
						Description:         "Operational software version of this TopoNode, e.g. 24.7.1 (for srl), or 24.7.r1 (for sros).",
						MarkdownDescription: "Operational software version of this TopoNode, e.g. 24.7.1 (for srl), or 24.7.r1 (for sros).",
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "TopoNodeStatus defines the observed state of TopoNode",
				MarkdownDescription: "TopoNodeStatus defines the observed state of TopoNode",
			},
		},
	}
}

type TopoNodeModel struct {
	ApiVersion types.String  `tfsdk:"api_version"`
	Hash       types.String  `tfsdk:"hash"`
	Kind       types.String  `tfsdk:"kind"`
	Metadata   MetadataValue `tfsdk:"metadata"`
	Name       types.String  `tfsdk:"name"`
	Namespace  types.String  `tfsdk:"namespace"`
	Spec       SpecValue     `tfsdk:"spec"`
	Status     StatusValue   `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	componentAttribute, ok := attributes["component"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`component is missing from object`)

		return nil, diags
	}

	componentVal, ok := componentAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`component expected to be basetypes.ListValue, was: %T`, componentAttribute))
	}

	licenseAttribute, ok := attributes["license"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`license is missing from object`)

		return nil, diags
	}

	licenseVal, ok := licenseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`license expected to be basetypes.StringValue, was: %T`, licenseAttribute))
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return nil, diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	nodeProfileAttribute, ok := attributes["node_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_profile is missing from object`)

		return nil, diags
	}

	nodeProfileVal, ok := nodeProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_profile expected to be basetypes.StringValue, was: %T`, nodeProfileAttribute))
	}

	nppAttribute, ok := attributes["npp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`npp is missing from object`)

		return nil, diags
	}

	nppVal, ok := nppAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`npp expected to be basetypes.ObjectValue, was: %T`, nppAttribute))
	}

	onBoardedAttribute, ok := attributes["on_boarded"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_boarded is missing from object`)

		return nil, diags
	}

	onBoardedVal, ok := onBoardedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_boarded expected to be basetypes.BoolValue, was: %T`, onBoardedAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return nil, diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	platformAttribute, ok := attributes["platform"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`platform is missing from object`)

		return nil, diags
	}

	platformVal, ok := platformAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`platform expected to be basetypes.StringValue, was: %T`, platformAttribute))
	}

	productionAddressAttribute, ok := attributes["production_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`production_address is missing from object`)

		return nil, diags
	}

	productionAddressVal, ok := productionAddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`production_address expected to be basetypes.ObjectValue, was: %T`, productionAddressAttribute))
	}

	serialNumberAttribute, ok := attributes["serial_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial_number is missing from object`)

		return nil, diags
	}

	serialNumberVal, ok := serialNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial_number expected to be basetypes.StringValue, was: %T`, serialNumberAttribute))
	}

	systemInterfaceAttribute, ok := attributes["system_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_interface is missing from object`)

		return nil, diags
	}

	systemInterfaceVal, ok := systemInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_interface expected to be basetypes.StringValue, was: %T`, systemInterfaceAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Component:         componentVal,
		License:           licenseVal,
		MacAddress:        macAddressVal,
		NodeProfile:       nodeProfileVal,
		Npp:               nppVal,
		OnBoarded:         onBoardedVal,
		OperatingSystem:   operatingSystemVal,
		Platform:          platformVal,
		ProductionAddress: productionAddressVal,
		SerialNumber:      serialNumberVal,
		SystemInterface:   systemInterfaceVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	componentAttribute, ok := attributes["component"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`component is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	componentVal, ok := componentAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`component expected to be basetypes.ListValue, was: %T`, componentAttribute))
	}

	licenseAttribute, ok := attributes["license"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`license is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	licenseVal, ok := licenseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`license expected to be basetypes.StringValue, was: %T`, licenseAttribute))
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	nodeProfileAttribute, ok := attributes["node_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_profile is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nodeProfileVal, ok := nodeProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_profile expected to be basetypes.StringValue, was: %T`, nodeProfileAttribute))
	}

	nppAttribute, ok := attributes["npp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`npp is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nppVal, ok := nppAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`npp expected to be basetypes.ObjectValue, was: %T`, nppAttribute))
	}

	onBoardedAttribute, ok := attributes["on_boarded"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_boarded is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	onBoardedVal, ok := onBoardedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_boarded expected to be basetypes.BoolValue, was: %T`, onBoardedAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	platformAttribute, ok := attributes["platform"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`platform is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	platformVal, ok := platformAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`platform expected to be basetypes.StringValue, was: %T`, platformAttribute))
	}

	productionAddressAttribute, ok := attributes["production_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`production_address is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	productionAddressVal, ok := productionAddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`production_address expected to be basetypes.ObjectValue, was: %T`, productionAddressAttribute))
	}

	serialNumberAttribute, ok := attributes["serial_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial_number is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	serialNumberVal, ok := serialNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial_number expected to be basetypes.StringValue, was: %T`, serialNumberAttribute))
	}

	systemInterfaceAttribute, ok := attributes["system_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_interface is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	systemInterfaceVal, ok := systemInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_interface expected to be basetypes.StringValue, was: %T`, systemInterfaceAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Component:         componentVal,
		License:           licenseVal,
		MacAddress:        macAddressVal,
		NodeProfile:       nodeProfileVal,
		Npp:               nppVal,
		OnBoarded:         onBoardedVal,
		OperatingSystem:   operatingSystemVal,
		Platform:          platformVal,
		ProductionAddress: productionAddressVal,
		SerialNumber:      serialNumberVal,
		SystemInterface:   systemInterfaceVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Component         basetypes.ListValue   `tfsdk:"component"`
	License           basetypes.StringValue `tfsdk:"license"`
	MacAddress        basetypes.StringValue `tfsdk:"mac_address"`
	NodeProfile       basetypes.StringValue `tfsdk:"node_profile"`
	Npp               basetypes.ObjectValue `tfsdk:"npp"`
	OnBoarded         basetypes.BoolValue   `tfsdk:"on_boarded"`
	OperatingSystem   basetypes.StringValue `tfsdk:"operating_system"`
	Platform          basetypes.StringValue `tfsdk:"platform"`
	ProductionAddress basetypes.ObjectValue `tfsdk:"production_address"`
	SerialNumber      basetypes.StringValue `tfsdk:"serial_number"`
	SystemInterface   basetypes.StringValue `tfsdk:"system_interface"`
	Version           basetypes.StringValue `tfsdk:"version"`
	state             attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["component"] = basetypes.ListType{
		ElemType: ComponentValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["license"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mac_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_profile"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["npp"] = basetypes.ObjectType{
		AttrTypes: NppValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["on_boarded"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["operating_system"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["platform"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["production_address"] = basetypes.ObjectType{
		AttrTypes: ProductionAddressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["serial_number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["system_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.Component.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["component"] = val

		val, err = v.License.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["license"] = val

		val, err = v.MacAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_address"] = val

		val, err = v.NodeProfile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_profile"] = val

		val, err = v.Npp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["npp"] = val

		val, err = v.OnBoarded.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["on_boarded"] = val

		val, err = v.OperatingSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system"] = val

		val, err = v.Platform.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["platform"] = val

		val, err = v.ProductionAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["production_address"] = val

		val, err = v.SerialNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["serial_number"] = val

		val, err = v.SystemInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_interface"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	component := types.ListValueMust(
		ComponentType{
			basetypes.ObjectType{
				AttrTypes: ComponentValue{}.AttributeTypes(ctx),
			},
		},
		v.Component.Elements(),
	)

	if v.Component.IsNull() {
		component = types.ListNull(
			ComponentType{
				basetypes.ObjectType{
					AttrTypes: ComponentValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Component.IsUnknown() {
		component = types.ListUnknown(
			ComponentType{
				basetypes.ObjectType{
					AttrTypes: ComponentValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var npp basetypes.ObjectValue

	if v.Npp.IsNull() {
		npp = types.ObjectNull(
			NppValue{}.AttributeTypes(ctx),
		)
	}

	if v.Npp.IsUnknown() {
		npp = types.ObjectUnknown(
			NppValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Npp.IsNull() && !v.Npp.IsUnknown() {
		npp = types.ObjectValueMust(
			NppValue{}.AttributeTypes(ctx),
			v.Npp.Attributes(),
		)
	}

	var productionAddress basetypes.ObjectValue

	if v.ProductionAddress.IsNull() {
		productionAddress = types.ObjectNull(
			ProductionAddressValue{}.AttributeTypes(ctx),
		)
	}

	if v.ProductionAddress.IsUnknown() {
		productionAddress = types.ObjectUnknown(
			ProductionAddressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ProductionAddress.IsNull() && !v.ProductionAddress.IsUnknown() {
		productionAddress = types.ObjectValueMust(
			ProductionAddressValue{}.AttributeTypes(ctx),
			v.ProductionAddress.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"component": basetypes.ListType{
			ElemType: ComponentValue{}.Type(ctx),
		},
		"license":      basetypes.StringType{},
		"mac_address":  basetypes.StringType{},
		"node_profile": basetypes.StringType{},
		"npp": basetypes.ObjectType{
			AttrTypes: NppValue{}.AttributeTypes(ctx),
		},
		"on_boarded":       basetypes.BoolType{},
		"operating_system": basetypes.StringType{},
		"platform":         basetypes.StringType{},
		"production_address": basetypes.ObjectType{
			AttrTypes: ProductionAddressValue{}.AttributeTypes(ctx),
		},
		"serial_number":    basetypes.StringType{},
		"system_interface": basetypes.StringType{},
		"version":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"component":          component,
			"license":            v.License,
			"mac_address":        v.MacAddress,
			"node_profile":       v.NodeProfile,
			"npp":                npp,
			"on_boarded":         v.OnBoarded,
			"operating_system":   v.OperatingSystem,
			"platform":           v.Platform,
			"production_address": productionAddress,
			"serial_number":      v.SerialNumber,
			"system_interface":   v.SystemInterface,
			"version":            v.Version,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Component.Equal(other.Component) {
		return false
	}

	if !v.License.Equal(other.License) {
		return false
	}

	if !v.MacAddress.Equal(other.MacAddress) {
		return false
	}

	if !v.NodeProfile.Equal(other.NodeProfile) {
		return false
	}

	if !v.Npp.Equal(other.Npp) {
		return false
	}

	if !v.OnBoarded.Equal(other.OnBoarded) {
		return false
	}

	if !v.OperatingSystem.Equal(other.OperatingSystem) {
		return false
	}

	if !v.Platform.Equal(other.Platform) {
		return false
	}

	if !v.ProductionAddress.Equal(other.ProductionAddress) {
		return false
	}

	if !v.SerialNumber.Equal(other.SerialNumber) {
		return false
	}

	if !v.SystemInterface.Equal(other.SystemInterface) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"component": basetypes.ListType{
			ElemType: ComponentValue{}.Type(ctx),
		},
		"license":      basetypes.StringType{},
		"mac_address":  basetypes.StringType{},
		"node_profile": basetypes.StringType{},
		"npp": basetypes.ObjectType{
			AttrTypes: NppValue{}.AttributeTypes(ctx),
		},
		"on_boarded":       basetypes.BoolType{},
		"operating_system": basetypes.StringType{},
		"platform":         basetypes.StringType{},
		"production_address": basetypes.ObjectType{
			AttrTypes: ProductionAddressValue{}.AttributeTypes(ctx),
		},
		"serial_number":    basetypes.StringType{},
		"system_interface": basetypes.StringType{},
		"version":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ComponentType{}

type ComponentType struct {
	basetypes.ObjectType
}

func (t ComponentType) Equal(o attr.Type) bool {
	other, ok := o.(ComponentType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ComponentType) String() string {
	return "ComponentType"
}

func (t ComponentType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	slotAttribute, ok := attributes["slot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slot is missing from object`)

		return nil, diags
	}

	slotVal, ok := slotAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slot expected to be basetypes.StringValue, was: %T`, slotAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ComponentValue{
		Kind:          kindVal,
		Slot:          slotVal,
		ComponentType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewComponentValueNull() ComponentValue {
	return ComponentValue{
		state: attr.ValueStateNull,
	}
}

func NewComponentValueUnknown() ComponentValue {
	return ComponentValue{
		state: attr.ValueStateUnknown,
	}
}

func NewComponentValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ComponentValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ComponentValue Attribute Value",
				"While creating a ComponentValue value, a missing attribute value was detected. "+
					"A ComponentValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ComponentValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ComponentValue Attribute Type",
				"While creating a ComponentValue value, an invalid attribute value was detected. "+
					"A ComponentValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ComponentValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ComponentValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ComponentValue Attribute Value",
				"While creating a ComponentValue value, an extra attribute value was detected. "+
					"A ComponentValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ComponentValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewComponentValueUnknown(), diags
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewComponentValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	slotAttribute, ok := attributes["slot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slot is missing from object`)

		return NewComponentValueUnknown(), diags
	}

	slotVal, ok := slotAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slot expected to be basetypes.StringValue, was: %T`, slotAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewComponentValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewComponentValueUnknown(), diags
	}

	return ComponentValue{
		Kind:          kindVal,
		Slot:          slotVal,
		ComponentType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewComponentValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ComponentValue {
	object, diags := NewComponentValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewComponentValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ComponentType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewComponentValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewComponentValueUnknown(), nil
	}

	if in.IsNull() {
		return NewComponentValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewComponentValueMust(ComponentValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ComponentType) ValueType(ctx context.Context) attr.Value {
	return ComponentValue{}
}

var _ basetypes.ObjectValuable = ComponentValue{}

type ComponentValue struct {
	Kind          basetypes.StringValue `tfsdk:"kind"`
	Slot          basetypes.StringValue `tfsdk:"slot"`
	ComponentType basetypes.StringValue `tfsdk:"type"`
	state         attr.ValueState
}

func (v ComponentValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["slot"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Slot.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slot"] = val

		val, err = v.ComponentType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ComponentValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ComponentValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ComponentValue) String() string {
	return "ComponentValue"
}

func (v ComponentValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"kind": basetypes.StringType{},
		"slot": basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"kind": v.Kind,
			"slot": v.Slot,
			"type": v.ComponentType,
		})

	return objVal, diags
}

func (v ComponentValue) Equal(o attr.Value) bool {
	other, ok := o.(ComponentValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Slot.Equal(other.Slot) {
		return false
	}

	if !v.ComponentType.Equal(other.ComponentType) {
		return false
	}

	return true
}

func (v ComponentValue) Type(ctx context.Context) attr.Type {
	return ComponentType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ComponentValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"kind": basetypes.StringType{},
		"slot": basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NppType{}

type NppType struct {
	basetypes.ObjectType
}

func (t NppType) Equal(o attr.Type) bool {
	other, ok := o.(NppType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NppType) String() string {
	return "NppType"
}

func (t NppType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NppValue{
		Mode:  modeVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewNppValueNull() NppValue {
	return NppValue{
		state: attr.ValueStateNull,
	}
}

func NewNppValueUnknown() NppValue {
	return NppValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNppValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NppValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NppValue Attribute Value",
				"While creating a NppValue value, a missing attribute value was detected. "+
					"A NppValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NppValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NppValue Attribute Type",
				"While creating a NppValue value, an invalid attribute value was detected. "+
					"A NppValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NppValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NppValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NppValue Attribute Value",
				"While creating a NppValue value, an extra attribute value was detected. "+
					"A NppValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NppValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNppValueUnknown(), diags
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewNppValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	if diags.HasError() {
		return NewNppValueUnknown(), diags
	}

	return NppValue{
		Mode:  modeVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewNppValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NppValue {
	object, diags := NewNppValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNppValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NppType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNppValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNppValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNppValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNppValueMust(NppValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NppType) ValueType(ctx context.Context) attr.Value {
	return NppValue{}
}

var _ basetypes.ObjectValuable = NppValue{}

type NppValue struct {
	Mode  basetypes.StringValue `tfsdk:"mode"`
	state attr.ValueState
}

func (v NppValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NppValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NppValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NppValue) String() string {
	return "NppValue"
}

func (v NppValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"mode": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"mode": v.Mode,
		})

	return objVal, diags
}

func (v NppValue) Equal(o attr.Value) bool {
	other, ok := o.(NppValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	return true
}

func (v NppValue) Type(ctx context.Context) attr.Type {
	return NppType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NppValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"mode": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ProductionAddressType{}

type ProductionAddressType struct {
	basetypes.ObjectType
}

func (t ProductionAddressType) Equal(o attr.Type) bool {
	other, ok := o.(ProductionAddressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProductionAddressType) String() string {
	return "ProductionAddressType"
}

func (t ProductionAddressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipv4Attribute, ok := attributes["ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4 is missing from object`)

		return nil, diags
	}

	ipv4Val, ok := ipv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4 expected to be basetypes.StringValue, was: %T`, ipv4Attribute))
	}

	ipv6Attribute, ok := attributes["ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6 is missing from object`)

		return nil, diags
	}

	ipv6Val, ok := ipv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6 expected to be basetypes.StringValue, was: %T`, ipv6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProductionAddressValue{
		Ipv4:  ipv4Val,
		Ipv6:  ipv6Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProductionAddressValueNull() ProductionAddressValue {
	return ProductionAddressValue{
		state: attr.ValueStateNull,
	}
}

func NewProductionAddressValueUnknown() ProductionAddressValue {
	return ProductionAddressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProductionAddressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProductionAddressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProductionAddressValue Attribute Value",
				"While creating a ProductionAddressValue value, a missing attribute value was detected. "+
					"A ProductionAddressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProductionAddressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProductionAddressValue Attribute Type",
				"While creating a ProductionAddressValue value, an invalid attribute value was detected. "+
					"A ProductionAddressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProductionAddressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProductionAddressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProductionAddressValue Attribute Value",
				"While creating a ProductionAddressValue value, an extra attribute value was detected. "+
					"A ProductionAddressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProductionAddressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProductionAddressValueUnknown(), diags
	}

	ipv4Attribute, ok := attributes["ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4 is missing from object`)

		return NewProductionAddressValueUnknown(), diags
	}

	ipv4Val, ok := ipv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4 expected to be basetypes.StringValue, was: %T`, ipv4Attribute))
	}

	ipv6Attribute, ok := attributes["ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6 is missing from object`)

		return NewProductionAddressValueUnknown(), diags
	}

	ipv6Val, ok := ipv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6 expected to be basetypes.StringValue, was: %T`, ipv6Attribute))
	}

	if diags.HasError() {
		return NewProductionAddressValueUnknown(), diags
	}

	return ProductionAddressValue{
		Ipv4:  ipv4Val,
		Ipv6:  ipv6Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProductionAddressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProductionAddressValue {
	object, diags := NewProductionAddressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProductionAddressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProductionAddressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProductionAddressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProductionAddressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProductionAddressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProductionAddressValueMust(ProductionAddressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProductionAddressType) ValueType(ctx context.Context) attr.Value {
	return ProductionAddressValue{}
}

var _ basetypes.ObjectValuable = ProductionAddressValue{}

type ProductionAddressValue struct {
	Ipv4  basetypes.StringValue `tfsdk:"ipv4"`
	Ipv6  basetypes.StringValue `tfsdk:"ipv6"`
	state attr.ValueState
}

func (v ProductionAddressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ipv4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Ipv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4"] = val

		val, err = v.Ipv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProductionAddressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProductionAddressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProductionAddressValue) String() string {
	return "ProductionAddressValue"
}

func (v ProductionAddressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ipv4": basetypes.StringType{},
		"ipv6": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ipv4": v.Ipv4,
			"ipv6": v.Ipv6,
		})

	return objVal, diags
}

func (v ProductionAddressValue) Equal(o attr.Value) bool {
	other, ok := o.(ProductionAddressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ipv4.Equal(other.Ipv4) {
		return false
	}

	if !v.Ipv6.Equal(other.Ipv6) {
		return false
	}

	return true
}

func (v ProductionAddressValue) Type(ctx context.Context) attr.Type {
	return ProductionAddressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProductionAddressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ipv4": basetypes.StringType{},
		"ipv6": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nodeDetailsAttribute, ok := attributes["node_details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_details is missing from object`)

		return nil, diags
	}

	nodeDetailsVal, ok := nodeDetailsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_details expected to be basetypes.StringValue, was: %T`, nodeDetailsAttribute))
	}

	nodeStateAttribute, ok := attributes["node_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_state is missing from object`)

		return nil, diags
	}

	nodeStateVal, ok := nodeStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_state expected to be basetypes.StringValue, was: %T`, nodeStateAttribute))
	}

	nppDetailsAttribute, ok := attributes["npp_details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`npp_details is missing from object`)

		return nil, diags
	}

	nppDetailsVal, ok := nppDetailsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`npp_details expected to be basetypes.StringValue, was: %T`, nppDetailsAttribute))
	}

	nppPodAttribute, ok := attributes["npp_pod"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`npp_pod is missing from object`)

		return nil, diags
	}

	nppPodVal, ok := nppPodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`npp_pod expected to be basetypes.StringValue, was: %T`, nppPodAttribute))
	}

	nppStateAttribute, ok := attributes["npp_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`npp_state is missing from object`)

		return nil, diags
	}

	nppStateVal, ok := nppStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`npp_state expected to be basetypes.StringValue, was: %T`, nppStateAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return nil, diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	platformAttribute, ok := attributes["platform"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`platform is missing from object`)

		return nil, diags
	}

	platformVal, ok := platformAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`platform expected to be basetypes.StringValue, was: %T`, platformAttribute))
	}

	simulateAttribute, ok := attributes["simulate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`simulate is missing from object`)

		return nil, diags
	}

	simulateVal, ok := simulateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`simulate expected to be basetypes.BoolValue, was: %T`, simulateAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		NodeDetails:     nodeDetailsVal,
		NodeState:       nodeStateVal,
		NppDetails:      nppDetailsVal,
		NppPod:          nppPodVal,
		NppState:        nppStateVal,
		OperatingSystem: operatingSystemVal,
		Platform:        platformVal,
		Simulate:        simulateVal,
		Version:         versionVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	nodeDetailsAttribute, ok := attributes["node_details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_details is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	nodeDetailsVal, ok := nodeDetailsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_details expected to be basetypes.StringValue, was: %T`, nodeDetailsAttribute))
	}

	nodeStateAttribute, ok := attributes["node_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	nodeStateVal, ok := nodeStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_state expected to be basetypes.StringValue, was: %T`, nodeStateAttribute))
	}

	nppDetailsAttribute, ok := attributes["npp_details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`npp_details is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	nppDetailsVal, ok := nppDetailsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`npp_details expected to be basetypes.StringValue, was: %T`, nppDetailsAttribute))
	}

	nppPodAttribute, ok := attributes["npp_pod"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`npp_pod is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	nppPodVal, ok := nppPodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`npp_pod expected to be basetypes.StringValue, was: %T`, nppPodAttribute))
	}

	nppStateAttribute, ok := attributes["npp_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`npp_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	nppStateVal, ok := nppStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`npp_state expected to be basetypes.StringValue, was: %T`, nppStateAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	platformAttribute, ok := attributes["platform"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`platform is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	platformVal, ok := platformAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`platform expected to be basetypes.StringValue, was: %T`, platformAttribute))
	}

	simulateAttribute, ok := attributes["simulate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`simulate is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	simulateVal, ok := simulateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`simulate expected to be basetypes.BoolValue, was: %T`, simulateAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		NodeDetails:     nodeDetailsVal,
		NodeState:       nodeStateVal,
		NppDetails:      nppDetailsVal,
		NppPod:          nppPodVal,
		NppState:        nppStateVal,
		OperatingSystem: operatingSystemVal,
		Platform:        platformVal,
		Simulate:        simulateVal,
		Version:         versionVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	NodeDetails     basetypes.StringValue `tfsdk:"node_details"`
	NodeState       basetypes.StringValue `tfsdk:"node_state"`
	NppDetails      basetypes.StringValue `tfsdk:"npp_details"`
	NppPod          basetypes.StringValue `tfsdk:"npp_pod"`
	NppState        basetypes.StringValue `tfsdk:"npp_state"`
	OperatingSystem basetypes.StringValue `tfsdk:"operating_system"`
	Platform        basetypes.StringValue `tfsdk:"platform"`
	Simulate        basetypes.BoolValue   `tfsdk:"simulate"`
	Version         basetypes.StringValue `tfsdk:"version"`
	state           attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["node_details"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["npp_details"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["npp_pod"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["npp_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["platform"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["simulate"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.NodeDetails.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_details"] = val

		val, err = v.NodeState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_state"] = val

		val, err = v.NppDetails.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["npp_details"] = val

		val, err = v.NppPod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["npp_pod"] = val

		val, err = v.NppState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["npp_state"] = val

		val, err = v.OperatingSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system"] = val

		val, err = v.Platform.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["platform"] = val

		val, err = v.Simulate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["simulate"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"node_details":     basetypes.StringType{},
		"node_state":       basetypes.StringType{},
		"npp_details":      basetypes.StringType{},
		"npp_pod":          basetypes.StringType{},
		"npp_state":        basetypes.StringType{},
		"operating_system": basetypes.StringType{},
		"platform":         basetypes.StringType{},
		"simulate":         basetypes.BoolType{},
		"version":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"node_details":     v.NodeDetails,
			"node_state":       v.NodeState,
			"npp_details":      v.NppDetails,
			"npp_pod":          v.NppPod,
			"npp_state":        v.NppState,
			"operating_system": v.OperatingSystem,
			"platform":         v.Platform,
			"simulate":         v.Simulate,
			"version":          v.Version,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NodeDetails.Equal(other.NodeDetails) {
		return false
	}

	if !v.NodeState.Equal(other.NodeState) {
		return false
	}

	if !v.NppDetails.Equal(other.NppDetails) {
		return false
	}

	if !v.NppPod.Equal(other.NppPod) {
		return false
	}

	if !v.NppState.Equal(other.NppState) {
		return false
	}

	if !v.OperatingSystem.Equal(other.OperatingSystem) {
		return false
	}

	if !v.Platform.Equal(other.Platform) {
		return false
	}

	if !v.Simulate.Equal(other.Simulate) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"node_details":     basetypes.StringType{},
		"node_state":       basetypes.StringType{},
		"npp_details":      basetypes.StringType{},
		"npp_pod":          basetypes.StringType{},
		"npp_state":        basetypes.StringType{},
		"operating_system": basetypes.StringType{},
		"platform":         basetypes.StringType{},
		"simulate":         basetypes.BoolType{},
		"version":          basetypes.StringType{},
	}
}

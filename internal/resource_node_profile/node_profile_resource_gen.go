// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_node_profile

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func NodeProfileResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^core\\.eda\\.nokia\\.com/v1$"), ""),
				},
				Default: stringdefault.StaticString("core.eda.nokia.com/v1"),
			},
			"kind": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^NodeProfile$"), ""),
				},
				Default: stringdefault.StaticString("NodeProfile"),
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.LengthAtMost(253),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"), ""),
						},
					},
					"namespace": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "name of the NodeProfile",
				MarkdownDescription: "name of the NodeProfile",
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotate": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Indicates if NPP should annotate sent configuration.",
						MarkdownDescription: "Indicates if NPP should annotate sent configuration.",
						Default:             booldefault.StaticBool(false),
					},
					"container_image": schema.StringAttribute{
						Optional:            true,
						Description:         "Container image to use when simulating TopoNodes referencing this NodeProfile, e.g. ghcr.io/nokia/srlinux:24.7.1.",
						MarkdownDescription: "Container image to use when simulating TopoNodes referencing this NodeProfile, e.g. ghcr.io/nokia/srlinux:24.7.1.",
					},
					"dhcp": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"dhcp4options": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"option": schema.StringAttribute{
											Required:            true,
											Description:         "DHCPv4 option to return to the TopoNode.",
											MarkdownDescription: "DHCPv4 option to return to the TopoNode.",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"1-SubnetMask",
													"2-TimeOffset",
													"3-Router",
													"4-TimeServer",
													"5-NameServer",
													"6-DomainNameServer",
													"7-LogServer",
													"8-QuoteServer",
													"9-LPRServer",
													"10-ImpressServer",
													"11-ResourceLocationServer",
													"12-HostName",
													"13-BootFileSize",
													"14-MeritDumpFile",
													"15-DomainName",
													"16-SwapServer",
													"17-RootPath",
													"18-ExtensionsPath",
													"19-IPForwarding",
													"20-NonLocalSourceRouting",
													"21-PolicyFilter",
													"22-MaximumDatagramAssemblySize",
													"23-DefaultIPTTL",
													"24-PathMTUAgingTimeout",
													"25-PathMTUPlateauTable",
													"26-InterfaceMTU",
													"27-AllSubnetsAreLocal",
													"28-BroadcastAddress",
													"29-PerformMaskDiscovery",
													"30-MaskSupplier",
													"31-PerformRouterDiscovery",
													"32-RouterSolicitationAddress",
													"33-StaticRoutingTable",
													"34-TrailerEncapsulation",
													"35-ArpCacheTimeout",
													"36-EthernetEncapsulation",
													"37-DefaulTCPTTL",
													"38-TCPKeepaliveInterval",
													"39-TCPKeepaliveGarbage",
													"40-NetworkInformationServiceDomain",
													"41-NetworkInformationServers",
													"42-NTPServers",
													"43-VendorSpecificInformation",
													"44-NetBIOSOverTCPIPNameServer",
													"45-NetBIOSOverTCPIPDatagramDistributionServer",
													"46-NetBIOSOverTCPIPNodeType",
													"47-NetBIOSOverTCPIPScope",
													"48-XWindowSystemFontServer",
													"49-XWindowSystemDisplayManager",
													"50-RequestedIPAddress",
													"51-IPAddressLeaseTime",
													"52-OptionOverload",
													"53-DHCPMessageType",
													"54-ServerIdentifier",
													"55-ParameterRequestList",
													"56-Message",
													"57-MaximumDHCPMessageSize",
													"58-RenewTimeValue",
													"59-RebindingTimeValue",
													"60-ClassIdentifier",
													"61-ClientIdentifier",
													"62-NetWareIPDomainName",
													"63-NetWareIPInformation",
													"64-NetworkInformationServicePlusDomain",
													"65-NetworkInformationServicePlusServers",
													"66-TFTPServerName",
													"67-BootfileName",
													"68-MobileIPHomeAgent",
													"69-SimpleMailTransportProtocolServer",
													"70-PostOfficeProtocolServer",
													"71-NetworkNewsTransportProtocolServer",
													"72-DefaultWorldWideWebServer",
													"73-DefaultFingerServer",
													"74-DefaultInternetRelayChatServer",
													"75-StreetTalkServer",
													"76-StreetTalkDirectoryAssistanceServer",
													"77-UserClassInformation",
													"78-SLPDirectoryAgent",
													"79-SLPServiceScope",
													"80-RapidCommit",
													"81-FQDN",
													"82-RelayAgentInformation",
													"83-InternetStorageNameService",
													"85-NDSServers",
													"86-NDSTreeName",
													"87-NDSContext",
													"88-BCMCSControllerDomainNameList",
													"89-BCMCSControllerIPv4AddressList",
													"90-Authentication",
													"91-ClientLastTransactionTime",
													"92-AssociatedIP",
													"93-ClientSystemArchitectureType",
													"94-ClientNetworkInterfaceIdentifier",
													"95-LDAP",
													"97-ClientMachineIdentifier",
													"98-OpenGroupUserAuthentication",
													"99-GeoConfCivic",
													"100-IEEE10031TZString",
													"101-ReferenceToTZDatabase",
													"112-NetInfoParentServerAddress",
													"113-NetInfoParentServerTag",
													"114-URL",
													"116-AutoConfigure",
													"117-NameServiceSearch",
													"118-SubnetSelection",
													"119-DNSDomainSearchList",
													"120-SIPServers",
													"121-ClasslessStaticRoute",
													"122-CCC",
													"123-GeoConf",
													"124-VendorIdentifyingVendorClass",
													"125-VendorIdentifyingVendorSpecific",
													"128-TFTPServerIPAddress",
													"129-CallServerIPAddress",
													"130-DiscriminationString",
													"131-RemoteStatisticsServerIPAddress",
													"132-8021PVLANID",
													"133-8021QL2Priority",
													"134-DiffservCodePoint",
													"135-HTTPProxyForPhoneSpecificApplications",
													"136-PANAAuthenticationAgent",
													"137-LoSTServer",
													"138-CAPWAPAccessControllerAddresses",
													"139-OPTIONIPv4AddressMoS",
													"140-OPTIONIPv4FQDNMoS",
													"141-SIPUAConfigurationServiceDomains",
													"142-OPTIONIPv4AddressANDSF",
													"143-OPTIONIPv6AddressANDSF",
													"150-TFTPServerAddress",
													"151-StatusCode",
													"152-BaseTime",
													"153-StartTimeOfState",
													"154-QueryStartTime",
													"155-QueryEndTime",
													"156-DHCPState",
													"157-DataSource",
													"175-Etherboot",
													"176-IPTelephone",
													"177-EtherbootPacketCableAndCableHome",
													"208-PXELinuxMagicString",
													"209-PXELinuxConfigFile",
													"210-PXELinuxPathPrefix",
													"211-PXELinuxRebootTime",
													"212-OPTION6RD",
													"213-OPTIONv4AccessDomain",
													"220-SubnetAllocation",
													"221-VirtualSubnetAllocation",
													"224-Reserved",
													"225-Reserved",
													"226-Reserved",
													"227-Reserved",
													"228-Reserved",
													"229-Reserved",
													"230-Reserved",
													"231-Reserved",
													"232-Reserved",
													"233-Reserved",
													"234-Reserved",
													"235-Reserved",
													"236-Reserved",
													"237-Reserved",
													"238-Reserved",
													"239-Reserved",
													"240-Reserved",
													"241-Reserved",
													"242-Reserved",
													"243-Reserved",
													"244-Reserved",
													"245-Reserved",
													"246-Reserved",
													"247-Reserved",
													"248-Reserved",
													"249-Reserved",
													"250-Reserved",
													"251-Reserved",
													"252-Reserved",
													"253-Reserved",
													"254-Reserved",
													"255-End",
												),
											},
										},
										"value": schema.ListAttribute{
											ElementType:         types.StringType,
											Required:            true,
											Description:         "Value to return to the TopoNode for the specified option.",
											MarkdownDescription: "Value to return to the TopoNode for the specified option.",
											Validators: []validator.List{
												listvalidator.SizeAtLeast(1),
											},
										},
									},
									CustomType: Dhcp4optionsType{
										ObjectType: types.ObjectType{
											AttrTypes: Dhcp4optionsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Description:         "DHCPv4 options to return to TopoNodes referencing this NodeProfile.",
								MarkdownDescription: "DHCPv4 options to return to TopoNodes referencing this NodeProfile.",
							},
							"dhcp6options": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"option": schema.StringAttribute{
											Required:            true,
											Description:         "DHCPv6 option to return to the TopoNode.",
											MarkdownDescription: "DHCPv6 option to return to the TopoNode.",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"59-BootfileUrl",
												),
											},
										},
										"value": schema.ListAttribute{
											ElementType:         types.StringType,
											Required:            true,
											Description:         "Value to return to the TopoNode for the specified option.",
											MarkdownDescription: "Value to return to the TopoNode for the specified option.",
											Validators: []validator.List{
												listvalidator.SizeAtLeast(1),
											},
										},
									},
									CustomType: Dhcp6optionsType{
										ObjectType: types.ObjectType{
											AttrTypes: Dhcp6optionsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Description:         "DHCPv6 options to return to TopoNodes referencing this NodeProfile.",
								MarkdownDescription: "DHCPv6 options to return to TopoNodes referencing this NodeProfile.",
							},
							"management_poolv4": schema.StringAttribute{
								Optional:            true,
								Description:         "IPInSubnetAllocationPool to use for IPv4 allocations of the management address for TopoNodes referencing this NodeProfile.",
								MarkdownDescription: "IPInSubnetAllocationPool to use for IPv4 allocations of the management address for TopoNodes referencing this NodeProfile.",
							},
							"management_poolv6": schema.StringAttribute{
								Optional:            true,
								Description:         "IPInSubnetAllocationPool to use for IPv6 allocations of the management address for TopoNodes referencing this NodeProfile.",
								MarkdownDescription: "IPInSubnetAllocationPool to use for IPv6 allocations of the management address for TopoNodes referencing this NodeProfile.",
							},
							"preferred_address_family": schema.StringAttribute{
								Optional:            true,
								Description:         "Preferred IP address family",
								MarkdownDescription: "Preferred IP address family",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"IPv4",
										"IPv6",
									),
								},
							},
						},
						CustomType: DhcpType{
							ObjectType: types.ObjectType{
								AttrTypes: DhcpValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "DHCP options to use when onboarding the TopoNode. Optional if not bootstrapping using EDA.",
						MarkdownDescription: "DHCP options to use when onboarding the TopoNode. Optional if not bootstrapping using EDA.",
					},
					"image_pull_secret": schema.StringAttribute{
						Optional:            true,
						Description:         "Secret used to authenticate to the container registry where the container image is hosted.",
						MarkdownDescription: "Secret used to authenticate to the container registry where the container image is hosted.",
					},
					"images": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"image": schema.StringAttribute{
									Required:            true,
									Description:         "URL hosting the software image, e.g. srlimages/srlinux-24.7.1.bin.",
									MarkdownDescription: "URL hosting the software image, e.g. srlimages/srlinux-24.7.1.bin.",
								},
								"image_md5": schema.StringAttribute{
									Optional:            true,
									Description:         "URL hosting the software image md5 hash. e.g. srlimages/srlinux-24.7.1.bin.md5.",
									MarkdownDescription: "URL hosting the software image md5 hash. e.g. srlimages/srlinux-24.7.1.bin.md5.",
								},
							},
							CustomType: ImagesType{
								ObjectType: types.ObjectType{
									AttrTypes: ImagesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "URLs hosting software images for bootstrapping TopoNodes referencing this NodeProfile.",
						MarkdownDescription: "URLs hosting software images for bootstrapping TopoNodes referencing this NodeProfile.",
					},
					"license": schema.StringAttribute{
						Optional:            true,
						Description:         "ConfigMap containing a license for TopoNodes referencing this NodeProfile.",
						MarkdownDescription: "ConfigMap containing a license for TopoNodes referencing this NodeProfile.",
					},
					"llm_db": schema.StringAttribute{
						Optional:            true,
						Description:         "URL containing LLDB  to use when interacting with LLM-DB and OpenAI for query autocompletion, e.g. http://eda-asvr/llmdb/ce-llm-db-srlinux-24.7.1.tar.gz.",
						MarkdownDescription: "URL containing LLDB  to use when interacting with LLM-DB and OpenAI for query autocompletion, e.g. http://eda-asvr/llmdb/ce-llm-db-srlinux-24.7.1.tar.gz.",
					},
					"node_user": schema.StringAttribute{
						Required:            true,
						Description:         "Reference to a NodeUser to use for authentication to TopoNodes referencing this NodeProfile.",
						MarkdownDescription: "Reference to a NodeUser to use for authentication to TopoNodes referencing this NodeProfile.",
					},
					"onboarding_password": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Sensitive:           true,
						Description:         "The password to use when onboarding TopoNodes referencing this NodeProfile, e.g. admin.",
						MarkdownDescription: "The password to use when onboarding TopoNodes referencing this NodeProfile, e.g. admin.",
						Default:             stringdefault.StaticString("NokiaSrl1!"),
					},
					"onboarding_username": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The username to use when onboarding TopoNodes referencing this NodeProfile, e.g. admin.",
						MarkdownDescription: "The username to use when onboarding TopoNodes referencing this NodeProfile, e.g. admin.",
						Default:             stringdefault.StaticString("admin"),
					},
					"operating_system": schema.StringAttribute{
						Required:            true,
						Description:         "Sets the operating system of this NodeProfile, e.g. srl.",
						MarkdownDescription: "Sets the operating system of this NodeProfile, e.g. srl.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"srl",
								"sros",
								"eos",
								"sonic",
								"ios-xr",
								"nxos",
								"linux",
							),
						},
					},
					"platform_path": schema.StringAttribute{
						Optional:            true,
						Description:         "JSPath to use for retrieving the version string from TopoNodes referencing this NodeProfile, e.g. .platform.chassis.type.",
						MarkdownDescription: "JSPath to use for retrieving the version string from TopoNodes referencing this NodeProfile, e.g. .platform.chassis.type.",
					},
					"port": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Port used to establish a connection to the TopoNode, e.g. 57400.",
						MarkdownDescription: "Port used to establish a connection to the TopoNode, e.g. 57400.",
						Validators: []validator.Int64{
							int64validator.Between(1, 65535),
						},
						Default: int64default.StaticInt64(57400),
					},
					"serial_number_path": schema.StringAttribute{
						Optional:            true,
						Description:         "JSPath to use for retrieving the serial number string from TopoNodes referencing this NodeProfile, e.g. .platform.chassis.serial-number.",
						MarkdownDescription: "JSPath to use for retrieving the serial number string from TopoNodes referencing this NodeProfile, e.g. .platform.chassis.serial-number.",
					},
					"version": schema.StringAttribute{
						Required:            true,
						Description:         "Sets the software version of this NodeProfile, e.g. 24.7.1 (for srl), or 24.7.r1 (for sros).",
						MarkdownDescription: "Sets the software version of this NodeProfile, e.g. 24.7.1 (for srl), or 24.7.r1 (for sros).",
					},
					"version_match": schema.StringAttribute{
						Optional:            true,
						Description:         "Regular expression to match the node-retrieved version string to TopoNode version, e.g. v0\\.0\\.0.*.",
						MarkdownDescription: "Regular expression to match the node-retrieved version string to TopoNode version, e.g. v0\\.0\\.0.*.",
					},
					"version_path": schema.StringAttribute{
						Optional:            true,
						Description:         "JSPath to use for retrieving the version string from TopoNodes referencing this NodeProfile, e.g. .system.information.version.",
						MarkdownDescription: "JSPath to use for retrieving the version string from TopoNodes referencing this NodeProfile, e.g. .system.information.version.",
					},
					"yang": schema.StringAttribute{
						Required:            true,
						Description:         "URL containing YANG modules and schema profile to use when interacting with TopoNodes referencing this NodeProfile, e.g. http://eda-asvr/schemaprofiles/srlinux-24.7.1.zip.",
						MarkdownDescription: "URL containing YANG modules and schema profile to use when interacting with TopoNodes referencing this NodeProfile, e.g. http://eda-asvr/schemaprofiles/srlinux-24.7.1.zip.",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "NodeProfileSpec defines the desired state of NodeProfile",
				MarkdownDescription: "NodeProfileSpec defines the desired state of NodeProfile",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
		},
	}
}

type NodeProfileModel struct {
	ApiVersion types.String  `tfsdk:"api_version"`
	Kind       types.String  `tfsdk:"kind"`
	Metadata   MetadataValue `tfsdk:"metadata"`
	Name       types.String  `tfsdk:"name"`
	Namespace  types.String  `tfsdk:"namespace"`
	Spec       SpecValue     `tfsdk:"spec"`
	Status     StatusValue   `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotateAttribute, ok := attributes["annotate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotate is missing from object`)

		return nil, diags
	}

	annotateVal, ok := annotateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotate expected to be basetypes.BoolValue, was: %T`, annotateAttribute))
	}

	containerImageAttribute, ok := attributes["container_image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container_image is missing from object`)

		return nil, diags
	}

	containerImageVal, ok := containerImageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container_image expected to be basetypes.StringValue, was: %T`, containerImageAttribute))
	}

	dhcpAttribute, ok := attributes["dhcp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp is missing from object`)

		return nil, diags
	}

	dhcpVal, ok := dhcpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp expected to be basetypes.ObjectValue, was: %T`, dhcpAttribute))
	}

	imagePullSecretAttribute, ok := attributes["image_pull_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_pull_secret is missing from object`)

		return nil, diags
	}

	imagePullSecretVal, ok := imagePullSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_pull_secret expected to be basetypes.StringValue, was: %T`, imagePullSecretAttribute))
	}

	imagesAttribute, ok := attributes["images"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`images is missing from object`)

		return nil, diags
	}

	imagesVal, ok := imagesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`images expected to be basetypes.ListValue, was: %T`, imagesAttribute))
	}

	licenseAttribute, ok := attributes["license"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`license is missing from object`)

		return nil, diags
	}

	licenseVal, ok := licenseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`license expected to be basetypes.StringValue, was: %T`, licenseAttribute))
	}

	llmDbAttribute, ok := attributes["llm_db"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`llm_db is missing from object`)

		return nil, diags
	}

	llmDbVal, ok := llmDbAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`llm_db expected to be basetypes.StringValue, was: %T`, llmDbAttribute))
	}

	nodeUserAttribute, ok := attributes["node_user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_user is missing from object`)

		return nil, diags
	}

	nodeUserVal, ok := nodeUserAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_user expected to be basetypes.StringValue, was: %T`, nodeUserAttribute))
	}

	onboardingPasswordAttribute, ok := attributes["onboarding_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`onboarding_password is missing from object`)

		return nil, diags
	}

	onboardingPasswordVal, ok := onboardingPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`onboarding_password expected to be basetypes.StringValue, was: %T`, onboardingPasswordAttribute))
	}

	onboardingUsernameAttribute, ok := attributes["onboarding_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`onboarding_username is missing from object`)

		return nil, diags
	}

	onboardingUsernameVal, ok := onboardingUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`onboarding_username expected to be basetypes.StringValue, was: %T`, onboardingUsernameAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return nil, diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	platformPathAttribute, ok := attributes["platform_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`platform_path is missing from object`)

		return nil, diags
	}

	platformPathVal, ok := platformPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`platform_path expected to be basetypes.StringValue, was: %T`, platformPathAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	serialNumberPathAttribute, ok := attributes["serial_number_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial_number_path is missing from object`)

		return nil, diags
	}

	serialNumberPathVal, ok := serialNumberPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial_number_path expected to be basetypes.StringValue, was: %T`, serialNumberPathAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	versionMatchAttribute, ok := attributes["version_match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version_match is missing from object`)

		return nil, diags
	}

	versionMatchVal, ok := versionMatchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version_match expected to be basetypes.StringValue, was: %T`, versionMatchAttribute))
	}

	versionPathAttribute, ok := attributes["version_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version_path is missing from object`)

		return nil, diags
	}

	versionPathVal, ok := versionPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version_path expected to be basetypes.StringValue, was: %T`, versionPathAttribute))
	}

	yangAttribute, ok := attributes["yang"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`yang is missing from object`)

		return nil, diags
	}

	yangVal, ok := yangAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`yang expected to be basetypes.StringValue, was: %T`, yangAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Annotate:           annotateVal,
		ContainerImage:     containerImageVal,
		Dhcp:               dhcpVal,
		ImagePullSecret:    imagePullSecretVal,
		Images:             imagesVal,
		License:            licenseVal,
		LlmDb:              llmDbVal,
		NodeUser:           nodeUserVal,
		OnboardingPassword: onboardingPasswordVal,
		OnboardingUsername: onboardingUsernameVal,
		OperatingSystem:    operatingSystemVal,
		PlatformPath:       platformPathVal,
		Port:               portVal,
		SerialNumberPath:   serialNumberPathVal,
		Version:            versionVal,
		VersionMatch:       versionMatchVal,
		VersionPath:        versionPathVal,
		Yang:               yangVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	annotateAttribute, ok := attributes["annotate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotate is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	annotateVal, ok := annotateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotate expected to be basetypes.BoolValue, was: %T`, annotateAttribute))
	}

	containerImageAttribute, ok := attributes["container_image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container_image is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	containerImageVal, ok := containerImageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container_image expected to be basetypes.StringValue, was: %T`, containerImageAttribute))
	}

	dhcpAttribute, ok := attributes["dhcp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	dhcpVal, ok := dhcpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp expected to be basetypes.ObjectValue, was: %T`, dhcpAttribute))
	}

	imagePullSecretAttribute, ok := attributes["image_pull_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_pull_secret is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	imagePullSecretVal, ok := imagePullSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_pull_secret expected to be basetypes.StringValue, was: %T`, imagePullSecretAttribute))
	}

	imagesAttribute, ok := attributes["images"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`images is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	imagesVal, ok := imagesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`images expected to be basetypes.ListValue, was: %T`, imagesAttribute))
	}

	licenseAttribute, ok := attributes["license"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`license is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	licenseVal, ok := licenseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`license expected to be basetypes.StringValue, was: %T`, licenseAttribute))
	}

	llmDbAttribute, ok := attributes["llm_db"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`llm_db is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	llmDbVal, ok := llmDbAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`llm_db expected to be basetypes.StringValue, was: %T`, llmDbAttribute))
	}

	nodeUserAttribute, ok := attributes["node_user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_user is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nodeUserVal, ok := nodeUserAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_user expected to be basetypes.StringValue, was: %T`, nodeUserAttribute))
	}

	onboardingPasswordAttribute, ok := attributes["onboarding_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`onboarding_password is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	onboardingPasswordVal, ok := onboardingPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`onboarding_password expected to be basetypes.StringValue, was: %T`, onboardingPasswordAttribute))
	}

	onboardingUsernameAttribute, ok := attributes["onboarding_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`onboarding_username is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	onboardingUsernameVal, ok := onboardingUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`onboarding_username expected to be basetypes.StringValue, was: %T`, onboardingUsernameAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	platformPathAttribute, ok := attributes["platform_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`platform_path is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	platformPathVal, ok := platformPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`platform_path expected to be basetypes.StringValue, was: %T`, platformPathAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	serialNumberPathAttribute, ok := attributes["serial_number_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial_number_path is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	serialNumberPathVal, ok := serialNumberPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial_number_path expected to be basetypes.StringValue, was: %T`, serialNumberPathAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	versionMatchAttribute, ok := attributes["version_match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version_match is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	versionMatchVal, ok := versionMatchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version_match expected to be basetypes.StringValue, was: %T`, versionMatchAttribute))
	}

	versionPathAttribute, ok := attributes["version_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version_path is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	versionPathVal, ok := versionPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version_path expected to be basetypes.StringValue, was: %T`, versionPathAttribute))
	}

	yangAttribute, ok := attributes["yang"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`yang is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	yangVal, ok := yangAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`yang expected to be basetypes.StringValue, was: %T`, yangAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Annotate:           annotateVal,
		ContainerImage:     containerImageVal,
		Dhcp:               dhcpVal,
		ImagePullSecret:    imagePullSecretVal,
		Images:             imagesVal,
		License:            licenseVal,
		LlmDb:              llmDbVal,
		NodeUser:           nodeUserVal,
		OnboardingPassword: onboardingPasswordVal,
		OnboardingUsername: onboardingUsernameVal,
		OperatingSystem:    operatingSystemVal,
		PlatformPath:       platformPathVal,
		Port:               portVal,
		SerialNumberPath:   serialNumberPathVal,
		Version:            versionVal,
		VersionMatch:       versionMatchVal,
		VersionPath:        versionPathVal,
		Yang:               yangVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Annotate           basetypes.BoolValue   `tfsdk:"annotate"`
	ContainerImage     basetypes.StringValue `tfsdk:"container_image"`
	Dhcp               basetypes.ObjectValue `tfsdk:"dhcp"`
	ImagePullSecret    basetypes.StringValue `tfsdk:"image_pull_secret"`
	Images             basetypes.ListValue   `tfsdk:"images"`
	License            basetypes.StringValue `tfsdk:"license"`
	LlmDb              basetypes.StringValue `tfsdk:"llm_db"`
	NodeUser           basetypes.StringValue `tfsdk:"node_user"`
	OnboardingPassword basetypes.StringValue `tfsdk:"onboarding_password"`
	OnboardingUsername basetypes.StringValue `tfsdk:"onboarding_username"`
	OperatingSystem    basetypes.StringValue `tfsdk:"operating_system"`
	PlatformPath       basetypes.StringValue `tfsdk:"platform_path"`
	Port               basetypes.Int64Value  `tfsdk:"port"`
	SerialNumberPath   basetypes.StringValue `tfsdk:"serial_number_path"`
	Version            basetypes.StringValue `tfsdk:"version"`
	VersionMatch       basetypes.StringValue `tfsdk:"version_match"`
	VersionPath        basetypes.StringValue `tfsdk:"version_path"`
	Yang               basetypes.StringValue `tfsdk:"yang"`
	state              attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 18)

	var val tftypes.Value
	var err error

	attrTypes["annotate"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["container_image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dhcp"] = basetypes.ObjectType{
		AttrTypes: DhcpValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["image_pull_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["images"] = basetypes.ListType{
		ElemType: ImagesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["license"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["llm_db"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_user"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["onboarding_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["onboarding_username"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["platform_path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["serial_number_path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version_match"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version_path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["yang"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 18)

		val, err = v.Annotate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotate"] = val

		val, err = v.ContainerImage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container_image"] = val

		val, err = v.Dhcp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp"] = val

		val, err = v.ImagePullSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_pull_secret"] = val

		val, err = v.Images.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["images"] = val

		val, err = v.License.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["license"] = val

		val, err = v.LlmDb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["llm_db"] = val

		val, err = v.NodeUser.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_user"] = val

		val, err = v.OnboardingPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["onboarding_password"] = val

		val, err = v.OnboardingUsername.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["onboarding_username"] = val

		val, err = v.OperatingSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system"] = val

		val, err = v.PlatformPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["platform_path"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.SerialNumberPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["serial_number_path"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		val, err = v.VersionMatch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version_match"] = val

		val, err = v.VersionPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version_path"] = val

		val, err = v.Yang.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["yang"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var dhcp basetypes.ObjectValue

	if v.Dhcp.IsNull() {
		dhcp = types.ObjectNull(
			DhcpValue{}.AttributeTypes(ctx),
		)
	}

	if v.Dhcp.IsUnknown() {
		dhcp = types.ObjectUnknown(
			DhcpValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Dhcp.IsNull() && !v.Dhcp.IsUnknown() {
		dhcp = types.ObjectValueMust(
			DhcpValue{}.AttributeTypes(ctx),
			v.Dhcp.Attributes(),
		)
	}

	images := types.ListValueMust(
		ImagesType{
			basetypes.ObjectType{
				AttrTypes: ImagesValue{}.AttributeTypes(ctx),
			},
		},
		v.Images.Elements(),
	)

	if v.Images.IsNull() {
		images = types.ListNull(
			ImagesType{
				basetypes.ObjectType{
					AttrTypes: ImagesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Images.IsUnknown() {
		images = types.ListUnknown(
			ImagesType{
				basetypes.ObjectType{
					AttrTypes: ImagesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"annotate":        basetypes.BoolType{},
		"container_image": basetypes.StringType{},
		"dhcp": basetypes.ObjectType{
			AttrTypes: DhcpValue{}.AttributeTypes(ctx),
		},
		"image_pull_secret": basetypes.StringType{},
		"images": basetypes.ListType{
			ElemType: ImagesValue{}.Type(ctx),
		},
		"license":             basetypes.StringType{},
		"llm_db":              basetypes.StringType{},
		"node_user":           basetypes.StringType{},
		"onboarding_password": basetypes.StringType{},
		"onboarding_username": basetypes.StringType{},
		"operating_system":    basetypes.StringType{},
		"platform_path":       basetypes.StringType{},
		"port":                basetypes.Int64Type{},
		"serial_number_path":  basetypes.StringType{},
		"version":             basetypes.StringType{},
		"version_match":       basetypes.StringType{},
		"version_path":        basetypes.StringType{},
		"yang":                basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotate":            v.Annotate,
			"container_image":     v.ContainerImage,
			"dhcp":                dhcp,
			"image_pull_secret":   v.ImagePullSecret,
			"images":              images,
			"license":             v.License,
			"llm_db":              v.LlmDb,
			"node_user":           v.NodeUser,
			"onboarding_password": v.OnboardingPassword,
			"onboarding_username": v.OnboardingUsername,
			"operating_system":    v.OperatingSystem,
			"platform_path":       v.PlatformPath,
			"port":                v.Port,
			"serial_number_path":  v.SerialNumberPath,
			"version":             v.Version,
			"version_match":       v.VersionMatch,
			"version_path":        v.VersionPath,
			"yang":                v.Yang,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotate.Equal(other.Annotate) {
		return false
	}

	if !v.ContainerImage.Equal(other.ContainerImage) {
		return false
	}

	if !v.Dhcp.Equal(other.Dhcp) {
		return false
	}

	if !v.ImagePullSecret.Equal(other.ImagePullSecret) {
		return false
	}

	if !v.Images.Equal(other.Images) {
		return false
	}

	if !v.License.Equal(other.License) {
		return false
	}

	if !v.LlmDb.Equal(other.LlmDb) {
		return false
	}

	if !v.NodeUser.Equal(other.NodeUser) {
		return false
	}

	if !v.OnboardingPassword.Equal(other.OnboardingPassword) {
		return false
	}

	if !v.OnboardingUsername.Equal(other.OnboardingUsername) {
		return false
	}

	if !v.OperatingSystem.Equal(other.OperatingSystem) {
		return false
	}

	if !v.PlatformPath.Equal(other.PlatformPath) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.SerialNumberPath.Equal(other.SerialNumberPath) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	if !v.VersionMatch.Equal(other.VersionMatch) {
		return false
	}

	if !v.VersionPath.Equal(other.VersionPath) {
		return false
	}

	if !v.Yang.Equal(other.Yang) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotate":        basetypes.BoolType{},
		"container_image": basetypes.StringType{},
		"dhcp": basetypes.ObjectType{
			AttrTypes: DhcpValue{}.AttributeTypes(ctx),
		},
		"image_pull_secret": basetypes.StringType{},
		"images": basetypes.ListType{
			ElemType: ImagesValue{}.Type(ctx),
		},
		"license":             basetypes.StringType{},
		"llm_db":              basetypes.StringType{},
		"node_user":           basetypes.StringType{},
		"onboarding_password": basetypes.StringType{},
		"onboarding_username": basetypes.StringType{},
		"operating_system":    basetypes.StringType{},
		"platform_path":       basetypes.StringType{},
		"port":                basetypes.Int64Type{},
		"serial_number_path":  basetypes.StringType{},
		"version":             basetypes.StringType{},
		"version_match":       basetypes.StringType{},
		"version_path":        basetypes.StringType{},
		"yang":                basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DhcpType{}

type DhcpType struct {
	basetypes.ObjectType
}

func (t DhcpType) Equal(o attr.Type) bool {
	other, ok := o.(DhcpType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DhcpType) String() string {
	return "DhcpType"
}

func (t DhcpType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dhcp4optionsAttribute, ok := attributes["dhcp4options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp4options is missing from object`)

		return nil, diags
	}

	dhcp4optionsVal, ok := dhcp4optionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp4options expected to be basetypes.ListValue, was: %T`, dhcp4optionsAttribute))
	}

	dhcp6optionsAttribute, ok := attributes["dhcp6options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp6options is missing from object`)

		return nil, diags
	}

	dhcp6optionsVal, ok := dhcp6optionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp6options expected to be basetypes.ListValue, was: %T`, dhcp6optionsAttribute))
	}

	managementPoolv4Attribute, ok := attributes["management_poolv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`management_poolv4 is missing from object`)

		return nil, diags
	}

	managementPoolv4Val, ok := managementPoolv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`management_poolv4 expected to be basetypes.StringValue, was: %T`, managementPoolv4Attribute))
	}

	managementPoolv6Attribute, ok := attributes["management_poolv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`management_poolv6 is missing from object`)

		return nil, diags
	}

	managementPoolv6Val, ok := managementPoolv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`management_poolv6 expected to be basetypes.StringValue, was: %T`, managementPoolv6Attribute))
	}

	preferredAddressFamilyAttribute, ok := attributes["preferred_address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_address_family is missing from object`)

		return nil, diags
	}

	preferredAddressFamilyVal, ok := preferredAddressFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_address_family expected to be basetypes.StringValue, was: %T`, preferredAddressFamilyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DhcpValue{
		Dhcp4options:           dhcp4optionsVal,
		Dhcp6options:           dhcp6optionsVal,
		ManagementPoolv4:       managementPoolv4Val,
		ManagementPoolv6:       managementPoolv6Val,
		PreferredAddressFamily: preferredAddressFamilyVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewDhcpValueNull() DhcpValue {
	return DhcpValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcpValueUnknown() DhcpValue {
	return DhcpValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcpValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DhcpValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DhcpValue Attribute Value",
				"While creating a DhcpValue value, a missing attribute value was detected. "+
					"A DhcpValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DhcpValue Attribute Type",
				"While creating a DhcpValue value, an invalid attribute value was detected. "+
					"A DhcpValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DhcpValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DhcpValue Attribute Value",
				"While creating a DhcpValue value, an extra attribute value was detected. "+
					"A DhcpValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DhcpValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcpValueUnknown(), diags
	}

	dhcp4optionsAttribute, ok := attributes["dhcp4options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp4options is missing from object`)

		return NewDhcpValueUnknown(), diags
	}

	dhcp4optionsVal, ok := dhcp4optionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp4options expected to be basetypes.ListValue, was: %T`, dhcp4optionsAttribute))
	}

	dhcp6optionsAttribute, ok := attributes["dhcp6options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp6options is missing from object`)

		return NewDhcpValueUnknown(), diags
	}

	dhcp6optionsVal, ok := dhcp6optionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp6options expected to be basetypes.ListValue, was: %T`, dhcp6optionsAttribute))
	}

	managementPoolv4Attribute, ok := attributes["management_poolv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`management_poolv4 is missing from object`)

		return NewDhcpValueUnknown(), diags
	}

	managementPoolv4Val, ok := managementPoolv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`management_poolv4 expected to be basetypes.StringValue, was: %T`, managementPoolv4Attribute))
	}

	managementPoolv6Attribute, ok := attributes["management_poolv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`management_poolv6 is missing from object`)

		return NewDhcpValueUnknown(), diags
	}

	managementPoolv6Val, ok := managementPoolv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`management_poolv6 expected to be basetypes.StringValue, was: %T`, managementPoolv6Attribute))
	}

	preferredAddressFamilyAttribute, ok := attributes["preferred_address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_address_family is missing from object`)

		return NewDhcpValueUnknown(), diags
	}

	preferredAddressFamilyVal, ok := preferredAddressFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_address_family expected to be basetypes.StringValue, was: %T`, preferredAddressFamilyAttribute))
	}

	if diags.HasError() {
		return NewDhcpValueUnknown(), diags
	}

	return DhcpValue{
		Dhcp4options:           dhcp4optionsVal,
		Dhcp6options:           dhcp6optionsVal,
		ManagementPoolv4:       managementPoolv4Val,
		ManagementPoolv6:       managementPoolv6Val,
		PreferredAddressFamily: preferredAddressFamilyVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewDhcpValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DhcpValue {
	object, diags := NewDhcpValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcpValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DhcpType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcpValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcpValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcpValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcpValueMust(DhcpValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DhcpType) ValueType(ctx context.Context) attr.Value {
	return DhcpValue{}
}

var _ basetypes.ObjectValuable = DhcpValue{}

type DhcpValue struct {
	Dhcp4options           basetypes.ListValue   `tfsdk:"dhcp4options"`
	Dhcp6options           basetypes.ListValue   `tfsdk:"dhcp6options"`
	ManagementPoolv4       basetypes.StringValue `tfsdk:"management_poolv4"`
	ManagementPoolv6       basetypes.StringValue `tfsdk:"management_poolv6"`
	PreferredAddressFamily basetypes.StringValue `tfsdk:"preferred_address_family"`
	state                  attr.ValueState
}

func (v DhcpValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["dhcp4options"] = basetypes.ListType{
		ElemType: Dhcp4optionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["dhcp6options"] = basetypes.ListType{
		ElemType: Dhcp6optionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["management_poolv4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["management_poolv6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["preferred_address_family"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Dhcp4options.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp4options"] = val

		val, err = v.Dhcp6options.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp6options"] = val

		val, err = v.ManagementPoolv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["management_poolv4"] = val

		val, err = v.ManagementPoolv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["management_poolv6"] = val

		val, err = v.PreferredAddressFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preferred_address_family"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DhcpValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DhcpValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DhcpValue) String() string {
	return "DhcpValue"
}

func (v DhcpValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dhcp4options := types.ListValueMust(
		Dhcp4optionsType{
			basetypes.ObjectType{
				AttrTypes: Dhcp4optionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Dhcp4options.Elements(),
	)

	if v.Dhcp4options.IsNull() {
		dhcp4options = types.ListNull(
			Dhcp4optionsType{
				basetypes.ObjectType{
					AttrTypes: Dhcp4optionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Dhcp4options.IsUnknown() {
		dhcp4options = types.ListUnknown(
			Dhcp4optionsType{
				basetypes.ObjectType{
					AttrTypes: Dhcp4optionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	dhcp6options := types.ListValueMust(
		Dhcp6optionsType{
			basetypes.ObjectType{
				AttrTypes: Dhcp6optionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Dhcp6options.Elements(),
	)

	if v.Dhcp6options.IsNull() {
		dhcp6options = types.ListNull(
			Dhcp6optionsType{
				basetypes.ObjectType{
					AttrTypes: Dhcp6optionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Dhcp6options.IsUnknown() {
		dhcp6options = types.ListUnknown(
			Dhcp6optionsType{
				basetypes.ObjectType{
					AttrTypes: Dhcp6optionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"dhcp4options": basetypes.ListType{
			ElemType: Dhcp4optionsValue{}.Type(ctx),
		},
		"dhcp6options": basetypes.ListType{
			ElemType: Dhcp6optionsValue{}.Type(ctx),
		},
		"management_poolv4":        basetypes.StringType{},
		"management_poolv6":        basetypes.StringType{},
		"preferred_address_family": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dhcp4options":             dhcp4options,
			"dhcp6options":             dhcp6options,
			"management_poolv4":        v.ManagementPoolv4,
			"management_poolv6":        v.ManagementPoolv6,
			"preferred_address_family": v.PreferredAddressFamily,
		})

	return objVal, diags
}

func (v DhcpValue) Equal(o attr.Value) bool {
	other, ok := o.(DhcpValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dhcp4options.Equal(other.Dhcp4options) {
		return false
	}

	if !v.Dhcp6options.Equal(other.Dhcp6options) {
		return false
	}

	if !v.ManagementPoolv4.Equal(other.ManagementPoolv4) {
		return false
	}

	if !v.ManagementPoolv6.Equal(other.ManagementPoolv6) {
		return false
	}

	if !v.PreferredAddressFamily.Equal(other.PreferredAddressFamily) {
		return false
	}

	return true
}

func (v DhcpValue) Type(ctx context.Context) attr.Type {
	return DhcpType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DhcpValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dhcp4options": basetypes.ListType{
			ElemType: Dhcp4optionsValue{}.Type(ctx),
		},
		"dhcp6options": basetypes.ListType{
			ElemType: Dhcp6optionsValue{}.Type(ctx),
		},
		"management_poolv4":        basetypes.StringType{},
		"management_poolv6":        basetypes.StringType{},
		"preferred_address_family": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Dhcp4optionsType{}

type Dhcp4optionsType struct {
	basetypes.ObjectType
}

func (t Dhcp4optionsType) Equal(o attr.Type) bool {
	other, ok := o.(Dhcp4optionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Dhcp4optionsType) String() string {
	return "Dhcp4optionsType"
}

func (t Dhcp4optionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	optionAttribute, ok := attributes["option"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`option is missing from object`)

		return nil, diags
	}

	optionVal, ok := optionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`option expected to be basetypes.StringValue, was: %T`, optionAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Dhcp4optionsValue{
		Option: optionVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewDhcp4optionsValueNull() Dhcp4optionsValue {
	return Dhcp4optionsValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcp4optionsValueUnknown() Dhcp4optionsValue {
	return Dhcp4optionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcp4optionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Dhcp4optionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Dhcp4optionsValue Attribute Value",
				"While creating a Dhcp4optionsValue value, a missing attribute value was detected. "+
					"A Dhcp4optionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Dhcp4optionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Dhcp4optionsValue Attribute Type",
				"While creating a Dhcp4optionsValue value, an invalid attribute value was detected. "+
					"A Dhcp4optionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Dhcp4optionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Dhcp4optionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Dhcp4optionsValue Attribute Value",
				"While creating a Dhcp4optionsValue value, an extra attribute value was detected. "+
					"A Dhcp4optionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Dhcp4optionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcp4optionsValueUnknown(), diags
	}

	optionAttribute, ok := attributes["option"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`option is missing from object`)

		return NewDhcp4optionsValueUnknown(), diags
	}

	optionVal, ok := optionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`option expected to be basetypes.StringValue, was: %T`, optionAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewDhcp4optionsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewDhcp4optionsValueUnknown(), diags
	}

	return Dhcp4optionsValue{
		Option: optionVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewDhcp4optionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Dhcp4optionsValue {
	object, diags := NewDhcp4optionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcp4optionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Dhcp4optionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcp4optionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcp4optionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcp4optionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcp4optionsValueMust(Dhcp4optionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Dhcp4optionsType) ValueType(ctx context.Context) attr.Value {
	return Dhcp4optionsValue{}
}

var _ basetypes.ObjectValuable = Dhcp4optionsValue{}

type Dhcp4optionsValue struct {
	Option basetypes.StringValue `tfsdk:"option"`
	Value  basetypes.ListValue   `tfsdk:"value"`
	state  attr.ValueState
}

func (v Dhcp4optionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["option"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Option.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["option"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Dhcp4optionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Dhcp4optionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Dhcp4optionsValue) String() string {
	return "Dhcp4optionsValue"
}

func (v Dhcp4optionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valueVal basetypes.ListValue
	switch {
	case v.Value.IsUnknown():
		valueVal = types.ListUnknown(types.StringType)
	case v.Value.IsNull():
		valueVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		valueVal, d = types.ListValue(types.StringType, v.Value.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"option": basetypes.StringType{},
			"value": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"option": basetypes.StringType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"option": v.Option,
			"value":  valueVal,
		})

	return objVal, diags
}

func (v Dhcp4optionsValue) Equal(o attr.Value) bool {
	other, ok := o.(Dhcp4optionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Option.Equal(other.Option) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v Dhcp4optionsValue) Type(ctx context.Context) attr.Type {
	return Dhcp4optionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Dhcp4optionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"option": basetypes.StringType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Dhcp6optionsType{}

type Dhcp6optionsType struct {
	basetypes.ObjectType
}

func (t Dhcp6optionsType) Equal(o attr.Type) bool {
	other, ok := o.(Dhcp6optionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Dhcp6optionsType) String() string {
	return "Dhcp6optionsType"
}

func (t Dhcp6optionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	optionAttribute, ok := attributes["option"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`option is missing from object`)

		return nil, diags
	}

	optionVal, ok := optionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`option expected to be basetypes.StringValue, was: %T`, optionAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Dhcp6optionsValue{
		Option: optionVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewDhcp6optionsValueNull() Dhcp6optionsValue {
	return Dhcp6optionsValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcp6optionsValueUnknown() Dhcp6optionsValue {
	return Dhcp6optionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcp6optionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Dhcp6optionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Dhcp6optionsValue Attribute Value",
				"While creating a Dhcp6optionsValue value, a missing attribute value was detected. "+
					"A Dhcp6optionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Dhcp6optionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Dhcp6optionsValue Attribute Type",
				"While creating a Dhcp6optionsValue value, an invalid attribute value was detected. "+
					"A Dhcp6optionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Dhcp6optionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Dhcp6optionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Dhcp6optionsValue Attribute Value",
				"While creating a Dhcp6optionsValue value, an extra attribute value was detected. "+
					"A Dhcp6optionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Dhcp6optionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcp6optionsValueUnknown(), diags
	}

	optionAttribute, ok := attributes["option"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`option is missing from object`)

		return NewDhcp6optionsValueUnknown(), diags
	}

	optionVal, ok := optionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`option expected to be basetypes.StringValue, was: %T`, optionAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewDhcp6optionsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewDhcp6optionsValueUnknown(), diags
	}

	return Dhcp6optionsValue{
		Option: optionVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewDhcp6optionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Dhcp6optionsValue {
	object, diags := NewDhcp6optionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcp6optionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Dhcp6optionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcp6optionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcp6optionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcp6optionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcp6optionsValueMust(Dhcp6optionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Dhcp6optionsType) ValueType(ctx context.Context) attr.Value {
	return Dhcp6optionsValue{}
}

var _ basetypes.ObjectValuable = Dhcp6optionsValue{}

type Dhcp6optionsValue struct {
	Option basetypes.StringValue `tfsdk:"option"`
	Value  basetypes.ListValue   `tfsdk:"value"`
	state  attr.ValueState
}

func (v Dhcp6optionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["option"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Option.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["option"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Dhcp6optionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Dhcp6optionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Dhcp6optionsValue) String() string {
	return "Dhcp6optionsValue"
}

func (v Dhcp6optionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valueVal basetypes.ListValue
	switch {
	case v.Value.IsUnknown():
		valueVal = types.ListUnknown(types.StringType)
	case v.Value.IsNull():
		valueVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		valueVal, d = types.ListValue(types.StringType, v.Value.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"option": basetypes.StringType{},
			"value": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"option": basetypes.StringType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"option": v.Option,
			"value":  valueVal,
		})

	return objVal, diags
}

func (v Dhcp6optionsValue) Equal(o attr.Value) bool {
	other, ok := o.(Dhcp6optionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Option.Equal(other.Option) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v Dhcp6optionsValue) Type(ctx context.Context) attr.Type {
	return Dhcp6optionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Dhcp6optionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"option": basetypes.StringType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ImagesType{}

type ImagesType struct {
	basetypes.ObjectType
}

func (t ImagesType) Equal(o attr.Type) bool {
	other, ok := o.(ImagesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ImagesType) String() string {
	return "ImagesType"
}

func (t ImagesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return nil, diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	imageMd5Attribute, ok := attributes["image_md5"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_md5 is missing from object`)

		return nil, diags
	}

	imageMd5Val, ok := imageMd5Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_md5 expected to be basetypes.StringValue, was: %T`, imageMd5Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ImagesValue{
		Image:    imageVal,
		ImageMd5: imageMd5Val,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewImagesValueNull() ImagesValue {
	return ImagesValue{
		state: attr.ValueStateNull,
	}
}

func NewImagesValueUnknown() ImagesValue {
	return ImagesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewImagesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ImagesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ImagesValue Attribute Value",
				"While creating a ImagesValue value, a missing attribute value was detected. "+
					"A ImagesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImagesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ImagesValue Attribute Type",
				"While creating a ImagesValue value, an invalid attribute value was detected. "+
					"A ImagesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImagesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ImagesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ImagesValue Attribute Value",
				"While creating a ImagesValue value, an extra attribute value was detected. "+
					"A ImagesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ImagesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewImagesValueUnknown(), diags
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	imageMd5Attribute, ok := attributes["image_md5"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_md5 is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	imageMd5Val, ok := imageMd5Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_md5 expected to be basetypes.StringValue, was: %T`, imageMd5Attribute))
	}

	if diags.HasError() {
		return NewImagesValueUnknown(), diags
	}

	return ImagesValue{
		Image:    imageVal,
		ImageMd5: imageMd5Val,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewImagesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ImagesValue {
	object, diags := NewImagesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewImagesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ImagesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewImagesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewImagesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewImagesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewImagesValueMust(ImagesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ImagesType) ValueType(ctx context.Context) attr.Value {
	return ImagesValue{}
}

var _ basetypes.ObjectValuable = ImagesValue{}

type ImagesValue struct {
	Image    basetypes.StringValue `tfsdk:"image"`
	ImageMd5 basetypes.StringValue `tfsdk:"image_md5"`
	state    attr.ValueState
}

func (v ImagesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["image_md5"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Image.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image"] = val

		val, err = v.ImageMd5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_md5"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ImagesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ImagesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ImagesValue) String() string {
	return "ImagesValue"
}

func (v ImagesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"image":     basetypes.StringType{},
		"image_md5": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"image":     v.Image,
			"image_md5": v.ImageMd5,
		})

	return objVal, diags
}

func (v ImagesValue) Equal(o attr.Value) bool {
	other, ok := o.(ImagesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Image.Equal(other.Image) {
		return false
	}

	if !v.ImageMd5.Equal(other.ImageMd5) {
		return false
	}

	return true
}

func (v ImagesValue) Type(ctx context.Context) attr.Type {
	return ImagesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ImagesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"image":     basetypes.StringType{},
		"image_md5": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	state attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}
